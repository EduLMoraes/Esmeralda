<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="dioxus-core"><title>dioxus_core - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-fa3bb1812debf86c.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="dioxus_core" data-themes="" data-resource-suffix="" data-rustdoc-version="1.74.1 (a28077b28 2023-12-04)" data-channel="1.74.1" data-search-js="search-8be46b629f5f14a8.js" data-settings-js="settings-74424d7eec62a23e.js" ><script src="../static.files/storage-fec3eaa3851e447d.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-c5bd66d33317d69f.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-5d8b3c7633ad77ba.css"></noscript><link rel="icon" href="https://avatars.githubusercontent.com/u/79236386"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../dioxus_core/index.html"><img src="https://avatars.githubusercontent.com/u/79236386" alt="logo"></a></nav><nav class="sidebar"><a class="logo-container" href="../dioxus_core/index.html"><img src="https://avatars.githubusercontent.com/u/79236386" alt="logo"></a><h2 class="location"><a href="#">Crate dioxus_core</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.4.3</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Aliases</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">dioxus_core</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../src/dioxus_core/lib.rs.html#1-104">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="dioxus-core"><a href="#dioxus-core">dioxus-core</a></h2>
<p>dioxus-core is a fast and featureful VirtualDom implementation written in and for Rust.</p>
<h2 id="features"><a href="#features">Features</a></h2>
<ul>
<li>Functions as components</li>
<li>Hooks for local state</li>
<li>Task pool for spawning futures</li>
<li>Template-based architecture</li>
<li>Asynchronous components</li>
<li>Suspense boundaries</li>
<li>Error boundaries through the <code>anyhow</code> crate</li>
<li>Customizable memoization</li>
</ul>
<p>If you are just starting, check out the Guides first.</p>
<h2 id="general-theory"><a href="#general-theory">General Theory</a></h2>
<p>The dioxus-core <code>VirtualDom</code> object is built around the concept of a <code>Template</code>. Templates describe a layout tree known at compile time with dynamic parts filled at runtime.</p>
<p>Each component in the VirtualDom works as a dedicated render loop where re-renders are triggered by events external to the VirtualDom, or from the components themselves.</p>
<p>When each component re-renders, it must return an <code>Element</code>. In Dioxus, the <code>Element</code> type is an alias for <code>Result&lt;VNode&gt;</code>. Between two renders, Dioxus compares the inner <code>VNode</code> object and calculates the differences between the dynamic portions of each internal <code>Template</code>. If any attributes or elements are different between the old layout and the new layout, Dioxus will write modifications to the <code>Mutations</code> object.</p>
<p>Dioxus expects the target renderer to save its nodes in a list. Each element is given a numerical ID which can be used to directly index into that list for O(1) lookups.</p>
<h2 id="usage"><a href="#usage">Usage</a></h2>
<p>All Dioxus apps start as just a function that takes the <a href="prelude/type.Scope.html" title="type dioxus_core::prelude::Scope"><code>Scope</code></a> object and returns an <a href="prelude/type.Element.html" title="type dioxus_core::prelude::Element"><code>Element</code></a>.</p>
<p>The <code>dioxus</code> crate exports the <code>rsx</code> macro which transforms a helpful, simpler syntax of Rust into the logic required to build Templates.</p>
<p>First, start with your app:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>dioxus::prelude::<span class="kw-2">*</span>;

<span class="comment">// First, declare a root component
</span><span class="kw">fn </span>app(cx: Scope) -&gt; Element {
    cx.render(<span class="macro">rsx!</span>{
        div { <span class="string">&quot;hello world&quot; </span>}
    })
}

<span class="kw">fn </span>main() {
    <span class="comment">// Next, create a new VirtualDom using this app as the root component.
    </span><span class="kw">let </span><span class="kw-2">mut </span>dom = VirtualDom::new(app);

    <span class="comment">// The initial render of the dom will generate a stream of edits for the real dom to apply
    </span><span class="kw">let </span>mutations = dom.rebuild();

    <span class="comment">// Somehow, you can apply these edits to the real dom
    </span>apply_edits_to_real_dom(mutations);
}
</code></pre></div>
<p>We can then wait for any asynchronous components or pending futures using the <code>wait_for_work()</code> method. If we have a deadline, then we can use render_with_deadline instead:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="comment">// Wait for the dom to be marked dirty internally
</span>dom.wait_for_work().<span class="kw">await</span>;

<span class="comment">// Or wait for a deadline and then collect edits
</span><span class="kw">let </span>mutations = dom.render_with_deadline(tokio::time::sleep(Duration::from_millis(<span class="number">16</span>)));</code></pre></div>
<p>If an event occurs from outside the VirtualDom while waiting for work, then we can cancel the wait using a <code>select!</code> block and inject the event.</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">loop </span>{
    <span class="macro">select! </span>{
        evt = real_dom.event() =&gt; dom.handle_event(<span class="string">&quot;click&quot;</span>, evt.data, evt.element, evt.bubbles),
        <span class="kw">_ </span>= dom.wait_for_work() =&gt; {}
    }

    <span class="comment">// Render any work without blocking the main thread for too long
    </span><span class="kw">let </span>mutations = dom.render_with_deadline(tokio::time::sleep(Duration::from_millis(<span class="number">10</span>)));

    <span class="comment">// And then apply the edits
    </span>real_dom.apply(mutations);
}
</code></pre></div>
<h3 id="internals"><a href="#internals">Internals</a></h3>
<p>Dioxus-core builds off the many frameworks that came before it. Notably, Dioxus borrows these concepts:</p>
<ul>
<li>React: hooks, concurrency, suspense</li>
<li>Dodrio: bump allocation, double buffering, and some diffing architecture</li>
</ul>
<p>Dioxus-core hits a very high level of parity with mature frameworks. However, Dioxus also brings some new unique features:</p>
<ul>
<li>managed lifetimes for borrowed data</li>
<li>placeholder approach for suspended vnodes</li>
<li>fiber/interruptible diffing algorithm</li>
<li>custom memory allocator for VNodes and all text content</li>
<li>support for fragments w/ lazy normalization</li>
<li>slab allocator for scopes</li>
<li>mirrored-slab approach for remote VirtualDoms</li>
<li>dedicated subtrees for rendering into separate contexts from the same app</li>
</ul>
<p>There’s certainly more to the story, but these optimizations make Dioxus memory use and allocation count extremely minimal. For an average application, no allocations may be needed once the app has been loaded. Only when new components are added to the dom will allocations occur. For a given component, the space of old VNodes is dynamically recycled as new nodes are added. Additionally, Dioxus tracks the average memory footprint of previous components to estimate how much memory allocate for future components.</p>
<p>All in all, Dioxus treats memory as a valuable resource. Combined with the memory-efficient footprint of Wasm compilation, Dioxus apps can scale to thousands of components and still stay snappy.</p>
<h3 id="goals"><a href="#goals">Goals</a></h3>
<p>The final implementation of Dioxus must:</p>
<ul>
<li>Be <strong>fast</strong>. Allocators are typically slow in Wasm/Rust, so we should have a smart way of allocating.</li>
<li>Be memory efficient. Servers should handle tens of thousands of simultaneous VDoms with no problem.</li>
<li>Be concurrent. Components should be able to pause rendering to let the screen paint the next frame.</li>
<li>Be disconnected from a specific renderer (no WebSys dependency in the core crate).</li>
<li>Support server-side-rendering (SSR). VNodes should render to a string that can be served via a web server.</li>
<li>Be “live”. Components should be able to be both server-rendered and client rendered without needing frontend APIs.</li>
<li>Be modular. Components and hooks should work anywhere without worrying about the target platform.</li>
</ul>
</div></details><h2 id="reexports" class="small-section-header"><a href="#reexports">Re-exports</a></h2><ul class="item-table"><li><div class="item-name" id="reexport.vdom_is_rendering"><code>pub use crate::innerlude::vdom_is_rendering;</code></div></li><li><div class="item-name" id="reexport.AnyValue"><code>pub use crate::innerlude::AnyValue;</code></div></li></ul><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="exports/index.html" title="mod dioxus_core::exports">exports</a></div><div class="desc docblock-short">Important dependencies that are used by the rest of the library
Feel free to just add the dependencies in your own Crates.toml</div></li><li><div class="item-name"><a class="mod" href="prelude/index.html" title="mod dioxus_core::prelude">prelude</a></div><div class="desc docblock-short">The purpose of this module is to alleviate imports of many common types</div></li></ul><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Attribute.html" title="struct dioxus_core::Attribute">Attribute</a></div><div class="desc docblock-short">An attribute on a DOM node, such as <code>id=&quot;my-thing&quot;</code> or <code>href=&quot;https://example.com&quot;</code></div></li><li><div class="item-name"><a class="struct" href="struct.CapturedError.html" title="struct dioxus_core::CapturedError">CapturedError</a></div><div class="desc docblock-short">An instance of an error captured by a descendant component.</div></li><li><div class="item-name"><a class="struct" href="struct.ElementId.html" title="struct dioxus_core::ElementId">ElementId</a></div><div class="desc docblock-short">An Element’s unique identifier.</div></li><li><div class="item-name"><a class="struct" href="struct.Event.html" title="struct dioxus_core::Event">Event</a></div><div class="desc docblock-short">A wrapper around some generic data that handles the event’s state</div></li><li><div class="item-name"><a class="struct" href="struct.LazyNodes.html" title="struct dioxus_core::LazyNodes">LazyNodes</a></div><div class="desc docblock-short">A concrete type provider for closures that build <a href="prelude/struct.VNode.html" title="struct dioxus_core::prelude::VNode"><code>VNode</code></a> structures.</div></li><li><div class="item-name"><a class="struct" href="struct.Mutations.html" title="struct dioxus_core::Mutations">Mutations</a></div><div class="desc docblock-short">A container for all the relevant steps to modify the Real DOM</div></li><li><div class="item-name"><a class="struct" href="struct.ScopeId.html" title="struct dioxus_core::ScopeId">ScopeId</a></div><div class="desc docblock-short">A component’s unique identifier.</div></li><li><div class="item-name"><a class="struct" href="struct.ScopeState.html" title="struct dioxus_core::ScopeState">ScopeState</a></div><div class="desc docblock-short">A component’s state separate from its props.</div></li><li><div class="item-name"><a class="struct" href="struct.Scoped.html" title="struct dioxus_core::Scoped">Scoped</a></div><div class="desc docblock-short">A wrapper around a component’s <a href="prelude/struct.ScopeState.html" title="struct dioxus_core::prelude::ScopeState"><code>ScopeState</code></a> and properties. The <a href="prelude/struct.ScopeState.html" title="struct dioxus_core::prelude::ScopeState"><code>ScopeState</code></a> provides the majority of methods
for the VirtualDom and component state.</div></li><li><div class="item-name"><a class="struct" href="struct.TaskId.html" title="struct dioxus_core::TaskId">TaskId</a></div><div class="desc docblock-short">A task’s unique identifier.</div></li><li><div class="item-name"><a class="struct" href="struct.Template.html" title="struct dioxus_core::Template">Template</a></div><div class="desc docblock-short">A static layout of a UI tree that describes a set of dynamic and static nodes.</div></li><li><div class="item-name"><a class="struct" href="struct.VComponent.html" title="struct dioxus_core::VComponent">VComponent</a></div><div class="desc docblock-short">An instance of a child component</div></li><li><div class="item-name"><a class="struct" href="struct.VNode.html" title="struct dioxus_core::VNode">VNode</a></div><div class="desc docblock-short">A reference to a template along with any context needed to hydrate it</div></li><li><div class="item-name"><a class="struct" href="struct.VPlaceholder.html" title="struct dioxus_core::VPlaceholder">VPlaceholder</a></div><div class="desc docblock-short">A placeholder node, used by suspense and fragments</div></li><li><div class="item-name"><a class="struct" href="struct.VText.html" title="struct dioxus_core::VText">VText</a></div><div class="desc docblock-short">An instance of some text, mounted to the DOM</div></li><li><div class="item-name"><a class="struct" href="struct.VirtualDom.html" title="struct dioxus_core::VirtualDom">VirtualDom</a></div><div class="desc docblock-short">A virtual node system that progresses user events and diffs UI trees.</div></li></ul><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.AttributeValue.html" title="enum dioxus_core::AttributeValue">AttributeValue</a></div><div class="desc docblock-short">Any of the built-in values that the Dioxus VirtualDom supports as dynamic attributes on elements</div></li><li><div class="item-name"><a class="enum" href="enum.BorrowedAttributeValue.html" title="enum dioxus_core::BorrowedAttributeValue">BorrowedAttributeValue</a></div><div class="desc docblock-short">Any of the built-in values that the Dioxus VirtualDom supports as dynamic attributes on elements that are borrowed</div></li><li><div class="item-name"><a class="enum" href="enum.DynamicNode.html" title="enum dioxus_core::DynamicNode">DynamicNode</a></div><div class="desc docblock-short">A node created at runtime</div></li><li><div class="item-name"><a class="enum" href="enum.Mutation.html" title="enum dioxus_core::Mutation">Mutation</a></div><div class="desc docblock-short">A <code>Mutation</code> represents a single instruction for the renderer to use to modify the UI tree to match the state
of the Dioxus VirtualDom.</div></li><li><div class="item-name"><a class="enum" href="enum.RenderReturn.html" title="enum dioxus_core::RenderReturn">RenderReturn</a></div><div class="desc docblock-short">The actual state of the component’s most recent computation</div></li><li><div class="item-name"><a class="enum" href="enum.TemplateAttribute.html" title="enum dioxus_core::TemplateAttribute">TemplateAttribute</a></div><div class="desc docblock-short">An attribute of the TemplateNode, created at compile time</div></li><li><div class="item-name"><a class="enum" href="enum.TemplateNode.html" title="enum dioxus_core::TemplateNode">TemplateNode</a></div><div class="desc docblock-short">A statically known node in a layout.</div></li></ul><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.IntoDynNode.html" title="trait dioxus_core::IntoDynNode">IntoDynNode</a></div><div class="desc docblock-short">A trait that allows various items to be converted into a dynamic node for the rsx macro</div></li><li><div class="item-name"><a class="trait" href="trait.Properties.html" title="trait dioxus_core::Properties">Properties</a></div><div class="desc docblock-short">Every “Props” used for a component must implement the <code>Properties</code> trait. This trait gives some hints to Dioxus
on how to memoize the props and some additional optimizations that can be made. We strongly encourage using the
derive macro to implement the <code>Properties</code> trait automatically as guarantee that your memoization strategy is safe.</div></li></ul><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.Fragment.html" title="fn dioxus_core::Fragment">Fragment</a></div><div class="desc docblock-short">Create inline fragments using Component syntax.</div></li><li><div class="item-name"><a class="fn" href="fn.fc_to_builder.html" title="fn dioxus_core::fc_to_builder">fc_to_builder</a></div><div class="desc docblock-short">This utility function launches the builder method so rsx! and html! macros can use the typed-builder pattern
to initialize a component’s props.</div></li></ul><h2 id="types" class="small-section-header"><a href="#types">Type Aliases</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.Component.html" title="type dioxus_core::Component">Component</a></div><div class="desc docblock-short">A <a href="prelude/type.Component.html" title="type dioxus_core::prelude::Component"><code>Component</code></a> is a function that takes a <a href="prelude/type.Scope.html" title="type dioxus_core::prelude::Scope"><code>Scope</code></a> and returns an <a href="prelude/type.Element.html" title="type dioxus_core::prelude::Element"><code>Element</code></a>.</div></li><li><div class="item-name"><a class="type" href="type.Element.html" title="type dioxus_core::Element">Element</a></div><div class="desc docblock-short">An <a href="prelude/type.Element.html" title="type dioxus_core::prelude::Element"><code>Element</code></a> is a possibly-none <a href="prelude/struct.VNode.html" title="struct dioxus_core::prelude::VNode"><code>VNode</code></a> created by calling <code>render</code> on <a href="prelude/type.Scope.html" title="type dioxus_core::prelude::Scope"><code>Scope</code></a> or <a href="prelude/struct.ScopeState.html" title="struct dioxus_core::prelude::ScopeState"><code>ScopeState</code></a>.</div></li><li><div class="item-name"><a class="type" href="type.Scope.html" title="type dioxus_core::Scope">Scope</a></div><div class="desc docblock-short">A wrapper around the <a href="prelude/struct.Scoped.html" title="struct dioxus_core::prelude::Scoped"><code>Scoped</code></a> object that contains a reference to the <a href="prelude/struct.ScopeState.html" title="struct dioxus_core::prelude::ScopeState"><code>ScopeState</code></a> and properties for a given
component.</div></li></ul></section></div></main></body></html>